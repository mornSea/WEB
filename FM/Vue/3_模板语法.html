<!DOCTYPE html> 
<html>
	<meta charset="UTF-8">
	<style><!--设置一些基本样式 背景色， 文字颜色， 居中-->
		* {margin: 0; padding: 0; text-align: center;}
		body {background-color: #F5F5F5; color: 757575;}  
	</style>
	<script scr="./vue_devloper.js"></script>	<!--导入vue-->
<body>
<!--插值-->
<span>Message: {{ msg }}</span><!--文本-->
<span v-once>这个不会变： {{ msg }}</span>	<!---once一次性插值-->、《

<p>Using mustaches: {{rawHtml  }}</p>	<!--用v-html 生成 原始html-->
<p>Using v-htmldirective: <span v-html="rawHtml"></span></p>

<div v-bind:id="dynamicId"></div>	<!--v-bind处理html特性-->
<button v-bind:disabled="idButtonDisbled">button</button>
<!--如果isButtonDisabledd的值不是这个,disabled特性不会包含在渲染出来的button元素里-->
 
{{ number + 1 }}   		<!--用js表达式 -->
{{ ok? 'yes' : 'no' }}
{{ message.aplit('').reverse().join('') }}
<div v-bind:id=" 'list-' + id ">    
<!--每个v-bind只能包含一个js表达式   并且js语句， 控制流都不可以； 模板表达式在沙盒里只能访问全局变量的白名单， 比如math和Date， 不应该访问用户定义的全局变量-->

<p v-if="seen">you see me  now</p>		<!--v-if指令根据seen的值的真假来决定插不插入p-->
<a v-bind:href="url">...</a>	<!--一些指令可以接受一个‘参数’  在指令的冒号后面（无空格）表示  如v-bind可以用于响应式的更新html特性-->
<a v-on:click="dosomething">...</a>		<!--v-on 像js的on一样 监听DOM事件-->

<form v-on:submit.prevent="onSubmit">...</form>		<!--修饰符是‘.’ (一点)指明的特殊后缀指出一个指令以特殊方式绑定  比如.prevent告诉v-on对于触发的事件调用event.preventDefault()-->

<!--缩写 ：   v-bind:href -> :href    ,     v-on:click -> @click  -->




</body>
<!--由于要等dom渲染出来再操作，so；使用vue的代码放在body后面-->
<script>
//使用html模板， 可以声明式的把DOM绑定到底层VUE实例的数据， 并且是合法的html， 可以被浏览器解析
//底层实现中 VUe把模板编译成虚拟渲染函数， 并且算出最少要重新渲染多少DOM ，把DOM操作次数减少到最少
//也可以不用模板， 直接写渲染（用JSX）， 虚拟DOM + 原生Js 之选






</script>
</html>
