//双狼　ａｎｇｕｌａｒ最佳实践

/* 　　常用前后端分离方法：　后端给出ＲＥＳＴ接口实现业务逻辑，　前端给出一个前端程序实现交互逻辑，　用ＣＩ（持续集成)服务器和端到端测试来协调两者

理想的开发流程：　　　　　　　　　　　　　　　　　　
                                        出框线图
            设计ｍｏｄｕｌｅ（接近数据传输对象）        设计测试用例
        写视图模板  　写控制器　　  写模拟服务器｀            ｜
        微调ＣＳＳ  　　重构　　　　制作真实数据         写端到端测试　            

前后端分离部署：　　
    分离架构：　用Ｎｉｇｎｘ／Ａｐａｃｈｅ／ＩＩＳ等专业服务器，　用静态方式部署前端，　然后通过反向代理把后端的访问转发给应用服务器，在客户端看来就向在一个服务器
    为了解决开发时的跨域问题，也可以通过反向代理让它们运行在一个域下，　还可以让业务服务器通过ＣＯＲＳ声明哪些域名下的脚本可以访问自己的服务（不兼容ＩＥ）, 这样还便于对静态文件通过ＣＤＮ进行优化
*/













//Nginx 基础部署配置
http{
    //...
    server {
        listen 80;
        server_name your.domain.name;
        location / {
            root /var/www/yourDocRoot/;
            index index.html index.htm;
        }
        location /api/{         //反向代理　　分别是头传ｈｔｔｐ头，　设置从这个服务器访问的地址
            proxy_set_header Host $http_host;
            proxy_pass http://another.domain.name:8080/api/;
        }
    }
}
//解决ｃｏｏｋｉｅ　ｐａｔｈ不通
location /api2/ {
    proxy_set_header Host $http_host;
    proxy_cookie_path /api/  /api2/;
    proxy_pass http://another.domain.name:8080/api/;
}

/* 样式中心页：　吧主要的样式都应用到一个样式中心页，所有人都看到它，　便于前端和设计协作，避免一个样式被多人重复定义
    ｈｔｍｌ表意性：　不使用ｂｉｇ，　ｆｏｎｔ，　ｃｅｎｔｅｒ等，　ｈｔｍｌ只是文档结构，　有了　ｈｅａｄｅｒ，　ｆｏｏｔｅｒ，　ｓｅｃｔｉｏｎ，也要求可读性
        如路径导航，不是用一堆ａ和／，　而是ｏｌ内的ｌｉ等嵌套结构，　ｌｉ里套ａ
        路径导航的类使用伪元素　：before
        .breadcrumb>li+li:before{
            padding: 0 5px;
            color: #ccc;
            content: "/\00a0";
        }

    table + display:table  布置表单ｆｏｒｍ　实现列根据内容自动调整宽度：
        .form-horizontal.auto-layout {
            display: table;     //重定义为ｔａｂｌｅ显示风格，　相当ｔａｂｌｅ元素
            //...
            > .form-group{
                display:table-row;  //把所有下级重定义为ｔａｂｌｅ－ｒｏｗ，　相当ｔｒ
                //...
                > * {
                    display: table-cell;    //下级所有元素设置为ｔａｂｌｅ－ｃｅｌｌ，　相当ｔｄ
                    //...
                }
*/















/*测试：　　
    原则：　
　　　  Ｆｉｌｔｅｒ和Ｓｅｒｖｉｃｅ覆盖式测试　
    　  装饰器指令在保持功能尽可能简单的前提下测试　 
        需求稳定的控制器和组件型指令进行覆盖　需求不稳定的先覆盖主体逻辑
        重构前先算涉及部分覆盖率，　尽力补充到百分之八十上再开始重构
        发现逻辑类的Ｂｕｇ，　补充相应的测试，让它能覆盖这个ｂｕｇ
*/
//单元测试　典型框架代码
describe('example >', function(){
    beforeEach(module('com.ngnice.app'));
    var $timeout;
    beforeEach(inject(function(_$timeout_){
        $timeout = _$timeout_;
    }));
    //这里写测试逻辑
    it('$timeout service', functiont(){
        $timeout(/* ... */);
    });
    //这里可以写更多测试逻辑
    it(/* .... */)
});

//测试Ｃｏｎｔｒｏｌｌｅｒ，　ｎｇ中是对ｓｃｏｐｅ进行初始化，　赋予值／行为，　ｓｏ测试以ｓｃｏｐｅ为测试标准
var scope = $rootScope.$new(true);              //创建一个ｓｃｏｐｅ对象，　ｔｒｕｅ表不会继承父级的变量　避免干扰
$controller('SomeController', ($scope: scope)); //找到ｓｏｍｅｃｏｎｔｒｏｌｌｅｒ，　并对ｓｃｏｐｅ初始化
expect(scope.name).toEqual('some one');         //期待ｓｃｏｐｅ上出现一个ｎａｍｅ属性，　值为ｓｏｍｅ　ｏｎｅ
expect(scope.qreeting()).toEqual('hi some one');//期待ｓｃｏｐｅ上出现一个ｇｒｅｅｔｉｎｇ函数，　调用的值为ｈｅｌｌｏ　ｓｏｍｅ　ｏｎｅ

//测试Ｓｅｒｖｉｃｅ　　它可以是类／函数／变量，　ｓｏ测试时没有固定形式，　但大体步骤和原理：　注入ｓｅｒｖｉｃｅ并保存为变量，根据类型使用它（函数调用／类先ｎｅｗ后检查成员／变量对比值）
var MyClass;
beforeEach(inject(function(_MyClass_){          //注入
    MyClass = _MyClass_;                        //赋值给外部变量
}));
it('someMethod(1) should ge 2', function(){     //这次假设是类，　就new+检查成员
    var obj = new MyClass();
    expect(obj.someMethod(1)).toEqual(2);
})

//测试Ｆｉｌｔｅｒ  它是（视图）无状态函数      （其实也是ｓｅｒｖｉｃｅ，　可直接用ｓｅｒｖｉｃｅ方式测试）
var uppercaseFilter = $filter('uppercase');     //获取ｕｐｐｅｒｃａｓｅ过滤器，
expect(uppercaseFilter('abc')).toEqual('ABC');  //输入ａｂｃ　应该调用后出ＡＢＣ

//测试组件型指令　　　用Ｃｏｎｔｒｏｌｌｅｒ赋予行为，　通过测试与指令相关的Ｃｏｎｔｒｏｌｌｅｒ实现指令测试
angular.module('com.ngnice.app')                //声明一个操纵此指令的控制器
    .controller('JobCategoryController', function JobCategoryController($scope){
        //...
    });
angular.module('com.ngnice.app')                //声明一个指令
    .directive('jobCategory', function jobCategory-Directive(){
        return {
            restrict: 'EA',
            scope: {                            //使用独立作用域
                configure: '='
            },
            templateUrl: 'components/configure/tree.html',      //指定模板
            controller: 'JobCategoryController' //指定刚定义的控制器
        };
    });                                         //之后就可像Ｃｏｎｔｒｏｌｌｅｒ一样测试

//测试装饰型指令   根据指令原理测试
var scope = $rootScope.$new(true);              //创建ｓｃｏｐｅ
var bfCaptcha = $compile('<img bf-captcha />')(scope);  //编译一个使用ｂｆＣａｐｔｃｈａ指令的ＤＯＭ元素，　并传入ｓｃｏｐｅ
scope.$digest();                                //调用ｓｃｏｐｅ．$ｄｉｇｅｓｔ（）
expect(bfCaptcha.attr('src'))                   //上面的这个指令应该给所在元素加一个ｓｒｃ属性，　值符合特定的正则表达式
    .toMatch(/\/api\/captcha\.jpg\?random=\d+/);

//测试网络请求
$httpBackend.whenGET('/someUrl')                //声明Ｍｏｃｋ服务，　模拟后端服务器
    .respond({name: 'wolf'}, {'X-Record-Count': 100});  
$http.get('/someUrl').success(function(data){   //调用网络接口
    expect(data.name).toBe('wolf');             
});
$httpBackend.flush();                           //刷新一次，　模拟后端返回请求，　在调用此命令前没ｓｕｃｃｅｓｓ中的回调不会执行

//测试ｓｅｔＴｉｍｅｏｕｔ类功能　　　同上，　对它出发的时机进行控制
var times = 1;
$timeout(function(){                            //定义超时回调
    ++times;
}, 1000);
$timeout.flush();                               //调用两次
$timeout.flush();
expect(times).toBe(3);                          //判断是否是期待结果




















/* 如何设计友好的ＲＥＳＴ　ＡＰＩ 
URL:
    一般由名称和ｉｄ组成（ｕｓｅｒ／１），　如没有技术限制，　ｉｄ最好使用ｕｕｉｄ，　简单，无锁，便于分布式系统，　不用担心ｉｄ冲突
    定义多层资源　（ｕｓｅｒｓ／１／ｆｉｌｅｓ／２），　过深的ｕｒｌ不好，参数太多，资源嵌套只要两层就够了，使用ｕｕｉｄ可以拆分成两级
    查询参数直接定义在ｕｒｌ里，　如　／ｕｓｅｒｓ／ａｇｅ／２０／６０　　　应该为　　／ｕｓｅｒｓ？ｍｉｎＡｇｅ＝２０＆＆ｍａｘＡｇｅ＝６０

资源拆分：
    资源和领域类有相当高的对应关系（还有其中的关联结构），　
    ＵＭＬ画出来时，　ＲＥＳＴ　ＡＰＩ也出来了：
        ＵＭＬ的常规关联（Ａｓｓｏｃｉａｔｉｏｎ　普通箭头）聚合（Ａｇｇｒｅｇａｔｉｏｎ空心方块）的关联不需要设计为多层资源，　
        而组合（Ｃｏｍｐｏｓｉｔｉｏｎ实心方块）则要设计多层资源
    　
资源命名：　　
    首先应该是名词，　动名词也可以，　但不能是动词，　
    作为操作的对象，　有时需要一个安全令牌（Ｔｏｋｅｎ），　ＡＰＩ可以是POST/tokens, 注销是DELETE/tokens/:id
    注意表意性，　表示业务含义，尽量同时保持清晰和简洁，　不如不要命名为ｕｓｅｒＦｉｌｅｓ－
    避免缩写，　尤其有歧义和自创的，　比如ｆｓ可以，　bt不可以，　没人知道是表示ｂｏｔｔｏｎ还是什么，　尽量让人一眼看懂

方法：
    遵循ＭＥＴＨＩＤ的使用规范，来自ＨＴＴＰ规范，　有两个重要的概念（安全性，　幂等性）
    安全性：　一项操作不会改变资源的状态，　即只把资源看成只读，　四大ＭＥＴＨＯＤ中，只有ＧＥＴ是安全的，ＨＥＡＤ也是安全的，其他的和ＰＡＴＣＨ也是不安全的
    幂等性：　同一操作执行ｎ次，　结果都是相同的，　不用担心破话业务逻辑，　四大ＭＥＴＨＯＤ中，只有ＰＯＳＴ是不幂等的

返回值：
    成功／失败错误码都是都是在响应（ｒｅｓｐｏｎｓｅ）头作为ＨＴＴＰ　Ｓｔａｔｕｓ　ｃｏｄｅ返回，而不能在响应体中返回，这是ＨＴＴＰ　ＲＥＳＴ双方规范要求
    便于在前端写一个过滤层（http interceptor），　对服务端错误进行统一处理，  可以对每一个发出／收到的包进行处理，　包括解析／修改内容
    状态码：
        ２００：ＧＥＴ／ＰＵＴ成功，　２０１：ＰＯＳＴ已创建，　２０２：已接受但未写入完成，　２０４：ＤＥＬＥＴＥ成功
        ４０１：尚未认证，　４０３：没有权限请求被拒绝，　４０４：资源不存在（列表列外），　４０９：版本冲突（锁）
        ４２２：不符合业务规则要求，　４２９：请求次数过多，　５００：服务器内部错误（给用户错误日志ｉｄ），　５０１：指定的方法声明但未实现

综合－分页ＡＰＩ：　
    分页参数设计：　两种方案：　页大小＋页号　｜｜　起始位置＋条数　　　（ＧＥＴ）
        后者更好，页码是前端的概念，而且和数据库分页的模式相同，
        可以每次请求几十到一百条数据，　然后展示时用每页１０项展示，　
        而且现在一般使用无限加载滚动，　这种模式下用页码的概念非常别扭　
    
    命名：组织内统一，　有以前的ＡＰＩ　要避免重名，　如果是新ＡＰＩ，　可以使用ｏｆｆｓｅｔ和ｓｉｚｅ，　
        条数要避免为ｌｅｎｇｔｈ，　因为和数组长度，　字符串长同名　容易干扰代码和第三方库

    返回值：　状态码按规范，　
    列表没有数据时返回２００和空数组，　
    有数据则返回一个符合条件的数据列表，总条数放响应头，添加一个头:　X-Record-Count

    METHOD: ＳＰＡ模式下，　总记录数可以保存在前端，没必要每个请求都重新请求一次总条目数，可以减轻服务器压力（除非需求需要频繁请求）
        取条目列表已经占用了ＧＥＴ　／ｕｓｅｒｓ这个ＡＰＩ，　设ＵＲＬ不能改，　换一个，用ＨＥＡＤ（它本身就是用来取响应头）
        而刚才的X-Record-Count就在头里，于是有了新ＡＰＩ：　ＨＥＡＤ／ｕｓｅｒｓ，　不返回相应体，　只是在相应头上带上了总条数

总结：　ＡＰＩ的设计取决于需求，　没有一劳永逸的方案，

*/
